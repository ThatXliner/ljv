# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

LJV (Lissajous Visualizer) is a desktop music visualizer built with Tauri + SvelteKit that creates real-time Lissajous curves from audio files. The visualizer uses WebGL for hardware-accelerated rendering and Web Audio API for audio processing.

## Architecture

### High-Level Design

The application follows a **browser-heavy architecture** where audio processing and visualization happen entirely in the browser, with Tauri providing only file system access. This design avoids IPC overhead and leverages the mature Web Audio API.

**Technology Stack:**
- Frontend: SvelteKit (SPA mode, SSR disabled) + Svelte 5 (runes-based reactivity)
- Desktop Runtime: Tauri v2 (minimal Rust backend)
- Rendering: WebGL2 with custom shaders
- Audio: Web Audio API (AnalyserNode, AudioContext)

### Key Architectural Decisions

1. **Audio Processing in Browser**: Uses Web Audio API instead of Rust audio crates to avoid IPC bottlenecks and leverage browser-native audio capabilities.

2. **Stereo Channel Mapping**: The Lissajous curve is generated by mapping stereo audio channels directly to X/Y coordinates (left channel = X-axis, right channel = Y-axis). This is the classic Lissajous approach.

3. **WebGL Points Rendering**: Uses `GL_POINTS` primitive with a circular buffer for trail effects, achieving smooth 60fps visualization with additive blending.

4. **Svelte 5 Runes State Management**: Global reactive state is managed through class instances with `$state` runes in `.svelte.ts` files, avoiding external state management libraries.

### Directory Structure

```
src/
├── lib/
│   ├── audio/              # Web Audio API integration
│   │   ├── AudioEngine.svelte.ts    # Audio playback & analysis
│   │   └── types.ts
│   ├── webgl/              # WebGL rendering pipeline
│   │   ├── LissajousRenderer.ts     # Core WebGL renderer
│   │   ├── shaders.ts               # GLSL vertex/fragment shaders
│   │   ├── utils.ts                 # WebGL helpers
│   │   └── types.ts
│   ├── math/
│   │   └── lissajous.ts    # Audio → Lissajous point conversion
│   ├── stores/
│   │   └── visualizer.svelte.ts     # Global reactive state
│   └── components/         # Svelte UI components
│       ├── Visualizer.svelte        # Canvas + render loop
│       ├── FileLoader.svelte        # Tauri file dialog
│       ├── Controls.svelte          # Playback & parameters
│       └── ColorPicker.svelte
└── routes/
    └── +page.svelte        # Main app layout
```

### Core Components

**AudioEngine** (`src/lib/audio/AudioEngine.svelte.ts`)
- Manages Web Audio API context and audio buffer
- Provides real-time time-domain data via `getLeftChannelData()` and `getRightChannelData()`
- Handles playback state (play, pause, seek)
- Uses Svelte 5 `$state` runes for reactive properties

**LissajousRenderer** (`src/lib/webgl/LissajousRenderer.ts`)
- Initializes WebGL2 context, compiles shaders, manages GPU resources
- Renders points using circular buffer approach for trail effect
- Supports both `GL_POINTS` and `GL_LINE_STRIP` render modes
- Implements additive blending for glow effect: `gl.blendFunc(GL_SRC_ALPHA, GL_ONE)`

**Visualizer Component** (`src/lib/components/Visualizer.svelte`)
- Orchestrates the render loop using `requestAnimationFrame`
- Fetches audio data, converts to Lissajous points, updates renderer
- Handles canvas resizing and WebGL resource cleanup

**Global State** (`src/lib/stores/visualizer.svelte.ts`)
- Exports singleton instances: `audioEngine`, `visualizerState`, `fileState`
- State is reactive across all components through Svelte 5 runes
- Must use class-based approach for `$state` in `.svelte.ts` files

### Data Flow

```
User selects file (FileLoader)
  → Tauri file dialog returns path
  → Read file via @tauri-apps/plugin-fs
  → Load ArrayBuffer into AudioEngine
  → User presses play (Controls)
  → Render loop starts (Visualizer)
    → AudioEngine.getLeftChannelData() + getRightChannelData()
    → audioToLissajousPoints() converts to Float32Array
    → LissajousRenderer.updatePoints() uploads to GPU
    → LissajousRenderer.render() draws frame
    → Loop continues via requestAnimationFrame
```

## Development Commands

### Frontend Development
```bash
npm run dev              # Start Vite dev server (http://localhost:1420)
npm run build           # Build frontend for production
npm run check           # Type-check TypeScript and Svelte files
npm run check:watch     # Type-check in watch mode
```

### Desktop Application
```bash
npm run tauri dev       # Run Tauri app in development mode (rebuilds Rust on changes)
npm run tauri build     # Build production desktop app
```

### Tauri-Specific
The Tauri backend (Rust) is in `src-tauri/`:
- Vite dev server runs on port 1420 (fixed for Tauri)
- HMR on port 1421
- Rust changes trigger automatic recompilation in dev mode

## Important Technical Details

### Svelte 5 Runes in Modules

When using `$state` runes in `.svelte.ts` files (not `.svelte` components), they **must** be class fields:

```typescript
// ✅ Correct
class MyState {
  value = $state(0);
}
export const state = new MyState();

// ❌ Wrong - build error
export const state = {
  value: $state(0)  // Error: $state can only be used as class field
};
```

### Tauri File Operations

File loading uses Tauri plugins, not browser APIs:
```typescript
import { open } from '@tauri-apps/plugin-dialog';
import { readFile } from '@tauri-apps/plugin-fs';

const selected = await open({ multiple: false, filters: [...] });
// selected is string | null (file path)
const fileData = await readFile(selected); // Uint8Array
```

### WebGL Resource Management

Always clean up WebGL resources in `onDestroy`:
```typescript
onDestroy(() => {
  cancelAnimationFrame(animationFrameId);
  renderer?.destroy();  // Deletes buffers, VAOs, programs
  audioEngine.destroy(); // Closes AudioContext
});
```

### Audio Processing Notes

- `AudioEngine` uses `AnalyserNode.getFloatTimeDomainData()` to get waveform samples
- FFT size is 2048 (configurable, must be power of 2)
- Stereo separation is simulated by offsetting right channel data
- For true stereo separation, use `ChannelSplitterNode` (currently simplified)

## Tauri Plugins Configuration

All plugins must be registered in `src-tauri/src/lib.rs`:
```rust
tauri::Builder::default()
    .plugin(tauri_plugin_dialog::init())
    .plugin(tauri_plugin_fs::init())
    .plugin(tauri_plugin_opener::init())
```

And added to `Cargo.toml` and `package.json` dependencies.

## Performance Considerations

- Limit trail length (default 2048 points) to maintain 60fps
- Use `Float32Array` for audio/point data (avoid allocations in render loop)
- Canvas resizing is debounced via `ResizeObserver`
- Additive blending (`GL_SRC_ALPHA, GL_ONE`) creates natural glow without post-processing
